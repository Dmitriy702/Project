import java.text.ParseException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Scanner;


/*
    - Класс, в названии которого есть слово Factory, как правило реализует паттерн какой-либо фабрики и вызов метода такого класса
      приводит к созданию нового объекта. В данном случае проблем несколько:
      Во-первых: название класса - ЛюдиФабрика или ФабрикаЛюди - и так и эдак какое-то говно =)
      Во-вторых: это не фабрика - этот класс не создает ни одного человека.
      В-третьих: не соблюдается принцип единой отвественности. Класс и ищет и удаляет и меню показывает и тд.
    - Везде в этом классе и других где используешь рекурсию замени на цикл.
    - Во всем коде должен остаться ровно один статический метод - это main.
    - Запомни один из главных принципов ооп - принцип единой отвественности. У тебя один класс должен выполнять одну работу.
      Если у тебя класс предназначен для хранения инфы, значит это его обязанность и другого он делать не должен.
      Это к слову о Person, Address, Contact. Если класс предназначен для запуска программы, пусть только это и делает
    - настрой .gitignore файл и удали из репы все файлы, кроме каталога src. В репе не должно быть ничего кроме исходников и файлов,
      которые нужны для запуска и работы проекта.
    - В верхнем правом углу идеи есть окно, в котором указывается желтый треугольник с восклицательным знаком.
      Это ворнинги компиляции, которые говорят тебе, сколько в кокретном классе у тебя мест с говнокодом. Обращай на это внимание.
      Ни в одном классе не должно быть ворнингов.
    - Переменные, методы и классы надо называть осмысленно, а не как бог на душу положил
    - Используй форматирование кода.
    - Вообще не вижу ни одного класса сервиса.
    - Нет разделения кода по пакетам.
 */
public class PeopleFactory
{
    static Scanner scanner = new Scanner(System.in);

    // Тип переменной должен быть интерфейсом. А название переменной отображать то, что она хранит
    private static final HashSet<Person> set = new HashSet<>();

    public static void main(String[] args) throws ParseException
    {
        // Здесь должен быть вызов объекта меню
        menu();
    }

    private static void menu() throws ParseException
    {
        System.out.println("Введите цифру для выбора действия" + "\n1 - добавить уинкальный аккаунт" + "\n2 - просмотр аккаунта(ов) по фамилии или всего списка (нужно что бы узнать id)" + "\n3 - удаление аккаунта по id" + "\n4 - добавление в друзья (нужны id аккаунтов)" + "\n5 - закрыть программу");
        switch (scanner.nextLine())
        {
            case "1":
            {
                set.add(Person.createPerson());
                menu();
            }
            case "2":
            {
                search();
                menu();
            }
            case "3":
            {
                deletePerson();
                menu();
            }
            case "4":
            {
                makeFriends();
                menu();
            }
            case "5":
            {
                System.out.println("Пока!");
                return;
            }
            default:
                menu();
        }
    }

    /*
        Зачем пробрасывется исключение?
        Логика добавления в друзья выглядит так, будто это делает третий человек для двух других.
        Странная логика.
        Обычно я сам добавляю в други.
        Ну и название метода немного некорректное. Тыж не друзей в нем делаешь, а условную дружбу создаешь между ними
     */
    private static void makeFriends() throws ParseException
    {
        // Что за название переменной
        int idAcc = 0;

        // Что за название переменной
        int idFri = 0;
        System.out.println("Введите id аккаунт (кому добавить друга)," + "\nили нажите ввод чтоб веруться в меню");
        try
        {
            idAcc = idChek();
        }
        catch (InputException e)
        {
            System.out.println(Messages.ID_EXCEPTION);
            makeFriends();
        }
        if (idAcc == 0)
        {
            return;
        }

        /*
            Раз уж замутил добавление в други, то сделай этот механизм с человеческим лицом.
            Пусть други добавляются по имени/фамилии, а не через знание айди
         */
        System.out.println("Введите id друга," + "\nили нажите ввод чтоб веруться в меню");
        try
        {
            idFri = idChek();
        }
        catch (InputException e)
        {
            System.out.println(Messages.ID_EXCEPTION);
            makeFriends();
        }
        if (idFri == 0)
        {
            return;
        }

        // Что за название переменной
        Person acc = null;
        // Что за название переменной
        Person fri = null;

        // Что за название переменных
        // Что-то мне подсказывает, что чел сам себя может добавить в други
        for (Person p : set)
        {
            if (idAcc == p.getId())
            {
                acc = p;
            }
            if (idFri == p.getId())
            {
                fri = p;
            }
        }
        if (acc != null && fri != null)
        {
            acc.addFriends(fri);
        }
        else
        {
            // С таким же успехом мог написать "где-то что-то когда-то произошло"
            // Напиши какой, у тебя ведь есть возможность это сделать
            System.out.println("Какой то аккаунт не найден!");
        }
    }

    // Зачем пробрасывется исключение
    private static void deletePerson() throws ParseException
    {
        System.out.println("Введите id удаляемого аккаунта" + "\nили нажмите ввод что бы вернуться в меню");
        int id = 0;
        try
        {
            // Удалять надо не по айди. Делать надо юзер френдли, а не заставлять помнить айди
            id = idChek();
        }
        catch (InputException e)
        {
            System.out.println(Messages.ID_EXCEPTION);
            deletePerson();
        }
        if (id == 0)
        {
            return;
        }
        Iterator<Person> iterator = set.iterator();

        // Сам ты флаг бля. Переменные надо называть исходя из того, что они хранят
        boolean flag = true;

        /*
            Во первых - переделай на стрим
            во-вторых - я так понимаю, что айди уникальны у каждого пользователя.
            Так зачем ты продолжаешь итерироваться, если удалил чела с нужной айдишкой
         */
        while (iterator.hasNext())
        {
            if (iterator.next().getId() == id)
            {
                iterator.remove();
                flag = false;

            }
        }
        if (flag)
        {
            System.out.println("Элемент с таким индексом не найден");
        }
    }

    // Зачем пробрасывется исключение
    private static void search() throws ParseException
    {
        System.out.println("Введите фамилию или нажмите ввод чтобы посмотреть весь список");
        String answer = scanner.nextLine();
        if (answer.matches("^$") && set.size() > 0)
        {
            // Что за название переменных
            for (Person p : set)
            {
                System.out.println(p);
            }
        }
        else if (set.size() == 0)
        {
            // Почему коллекция. Мб сообщение должно быть "Лох пидр нет друзей!"
            // Воображаемый пользователь не поймет о какой коллекции идет речь.
            // Сообщения для пользователя должны быть понятны ему.
            System.out.println("Коллекция пуста :(");
        }
        else // Перепиши поиск на стрим
        {
            // Эта переменная не нужна будет
            int counter = 0;
            // Что за название переменных
            for (Person p : set)
            {
                /*
                   Запомни простое правило при написании кода - он должен читаться как предложение, составленное психически здоровым человеком
                   Давай прочтем строку кода с if
                   если фамилия п соответствует ответу - предложение курильщика
                   а могло бы
                   если фамилия человека соответствует фамилии - так уже ближе к званию "мамино солнышко"
                 */
                if (p.getSurname().equals(answer))
                {
                    System.out.println(p);
                    counter++;
                }
            }
            if (counter == 0)
            {
                System.out.println("Аккаунт с такой фамилией не найден!");
            }
        }
    }

    private static int idChek()
    {
        /*
            Что за название переменной.
            У тебя тотальная любовь к реджексу я смотрю.
            Проверку можно упростить на мой взгяд.
            Сразу брать и парсит к инту, если не упало на этой стадии значит и вправду число, затем проверили, что не < 0 и готово.
            ДУмается мне что такое работать будет быстрее.
         */
        String s = scanner.nextLine();
        if (s.matches("[0-9]{1,16}|^$"))
        {
            if (s.length() == 0)
            {
                return 0;
            }
            else
            {
                return Integer.parseInt(s);
            }
        }
        else
        {
            throw new InputException(Messages.ID_EXCEPTION);
        }
    }
}
